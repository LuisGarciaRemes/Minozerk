<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 7</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 1024,
        height: 804,update: update,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0},
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var player;
    var playerPrevX;
    var playerPrevY;
    var enemies;
    var enemySpeed;
    var boarderWalls;
    var cursors;
    var button;
    var projectiles;
    var enemyProjectiles;
    var scoreText;
    var score;
    var projectileSpeed;
    var playerSpeed;
    var isShooting;
    var shootingTimer;
    var shootingDelay;
    var canShoot;
    var facingRight;
    var levelOneWalls;
    var levelTwoWalls;
    var nextRoomColliders;
    var detectionOffset;
    var currentRoom;
    var nextRoom;
    var lives;
    var otto;
    var ottoTimer;
    var entryX;
    var entryY;
    var doors;
    var canTakeDamage;
    var unit;
    var sightRange;
    var time;
    var levelOnePosList;
    var levelTwoPosList;
    var canTakeDamage;
    var growl;
    var woosh;
    var grunt;

    var game = new Phaser.Game(config);

    function preload ()
    {
      this.load.audio('theme',[
      'assets/slowlycreeping.mp3'
      ]);
      this.load.audio('growl',[
      'assets/growl.mp3'
      ]);
      this.load.audio('woosh',[
      'assets/woosh.mp3'
      ]);
      this.load.audio('grunt',[
      'assets/grunt.mp3'
      ]);
      this.load.audio('wallcrush',[
      'assets/wallcrush.mp3'
      ]);
      this.load.image('BG', 'assets/floorsprites.png');
      this.load.image('horizontalwall', 'assets/wall_horizontal.png');
      this.load.image('verticalwall', 'assets/wall_vertical.png');
      this.load.image('lowerleftwall', 'assets/wall_lower_left.png');
      this.load.image('lowerrightwall', 'assets/wall_lower_right.png');
      this.load.image('upperleftwall', 'assets/wall_upper_left.png');
      this.load.image('upperrightwall', 'assets/wall_upper_right.png');
      this.load.image('horizontalCollider', 'assets/horizontalCollider.png');
      this.load.image('verticalCollider', 'assets/verticalCollider.png');
      this.load.image('endcapleft', 'assets/endcapleft.png');
      this.load.image('endcapright', 'assets/endcapright.png');
      this.load.image('endcapup', 'assets/endcapup.png');
      this.load.image('endcapdown', 'assets/endcapdown.png');
      this.load.image('solowall', 'assets/Solo.png');
      this.load.spritesheet('bone', 'assets/skeleton_projectile_sheet_small.png', { frameWidth: 14, frameHeight: 14 });
      this.load.spritesheet('player_projectile', 'assets/player_projectile.png', { frameWidth: 14, frameHeight: 14 });
      this.load.spritesheet('otto', 'assets/minotaur_walk_sheet.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('ottoleft', 'assets/minotaur_walk_sheetleft.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('duderight', 'assets/player_walkcycle_sheet.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('dudeleft', 'assets/player_walkcycle_sheetleft.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('idleright', 'assets/player_sprite.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('idleleft', 'assets/player_spriteleft.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('enemyright', 'assets/skeleton_walk_sheet.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('enemyleft', 'assets/skeleton_walk_sheetleft.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('playerThrowRight', 'assets/player_throw_sheet_right.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('playerThrowLeft', 'assets/player_throw_sheet_left.png', { frameWidth: 32, frameHeight: 32 });

        projectileSpeed = 250;
        playerSpeed = 120;
        enemySpeed = 110;
        isShooting = false;
        canShoot = true;
        shootingTimer = 0;
        shootingDelay = 250; // 1000 = 1 second
        facingRight = true;
        score = 0;
        playerPrevX = 0;
        playerPrevY = 0;
        detectionOffset = 15;
        firstRoom = true;
        unit = 32;
        sightRange = 350;
        canTakeDamage = true;
    }

    function create ()
    {
      var music = this.sound.add('theme');
      growl = this.sound.add('growl');
      woosh = this.sound.add('woosh');
      grunt = this.sound.add('grunt');
      wallcrush = this.sound.add('wallcrush');

          music.setLoop(true);
          music.play();

        this.add.image(512, 351, 'BG');
        nextRoomColliders = this.physics.add.staticGroup();
        doors = this.physics.add.staticGroup();
        boarderWalls = this.physics.add.staticGroup();
        levelOneWalls = this.physics.add.staticGroup();
        levelTwoWalls = this.physics.add.staticGroup();
        lives = this.add.group();
        otto = this.physics.add.sprite(500, 450, 'otto');
        levelOnePosList = new Phaser.Structs.List();
        levelTwoPosList = new Phaser.Structs.List();
        resetOtto(time);

        enemies = this.physics.add.group();
        enemies.createMultiple({
    key: 'enemyright',visible:true,active:true,
    repeat: 12,
    setXY: { x: 200, y: 100,stepX: 70, stepY: 50}
        });
        createNextRoomColliders();
        createBoarder(); // creats the wall for the game boarder.
        createLevelOne();
        createLevelTwo();
        toggleLevelOff(levelTwoWalls);
        currentRoom = levelOneWalls;


        projectiles = this.physics.add.group();
        projectiles.createMultiple({
    key: 'player_projectile',visible:false,active:false,
    repeat: 20,
    setXY: { x: 0, y: 580}
          });

          lives.createMultiple({
      key: 'duderight',visible:true,active:true,
      repeat: 2,
      setXY: { x: 240, y: 740 , stepX: 40}
            });

          var i = 0;
          enemyProjectiles = this.physics.add.group();
          enemyProjectiles.createMultiple({
      key: 'bone',visible:false,active:false,
      repeat: 12,
      setXY: { x: 0, y: 580}
            });
              enemies.children.iterate(function (enemy) {
                enemy.child = enemyProjectiles.getFirstNth(i);
                enemy.child.disableBody();
                i++;
              });
        player = this.physics.add.sprite(100, 350, 'duderight');
        player.setCollideWorldBounds(true);
        createAnimations(this.anims);// creates the animations. passes in the animator from the game

        cursors = this.input.keyboard.createCursorKeys();
        button = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        this.physics.add.overlap(nextRoomColliders, player, loadNextRoom, null, this);
        this.physics.add.overlap(enemies, projectiles, destroyBothPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, projectiles, destroyBothNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, player, destroyBothNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles,enemies , destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemies, player, destroyBothPoints, null, this);
        this.physics.add.overlap(projectiles, boarderWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(projectiles, levelOneWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, levelOneWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, boarderWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, nextRoomColliders, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(player, otto, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemies, otto, destroyOtherPoints, null, this);
        this.physics.add.overlap(projectiles, levelTwoWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, levelTwoWalls, destroyOtherNoPoints, null, this);
        this.physics.add.collider(player, boarderWalls);
        this.physics.add.collider(player, levelOneWalls);
        this.physics.add.collider(player, levelTwoWalls);
        this.physics.add.collider(player, doors);
        this.physics.add.collider(otto, boarderWalls);

        //switch the // for minotar destoyrswalls
        //this.physics.add.collider(otto, levelOneWalls);
        //this.physics.add.collider(otto, levelTwoWalls);
        this.physics.add.overlap(levelOneWalls,otto,destroyOtherNoPoints, null, this);
        this.physics.add.overlap(levelTwoWalls,otto,destroyOtherNoPoints, null, this);

        this.physics.add.collider(enemies, boarderWalls);
        this.physics.add.collider(enemies, enemies);
        this.physics.add.collider(enemies, levelOneWalls);
        this.physics.add.collider(enemies, levelTwoWalls);

        entryX = player.x;
        entryY = player.y;
        resetEnemies(time);
        scoreText = this.add.text(440, 720, 'score: 0', { fontSize: '32px', fill: '#999' });
    }

    function removeLife()
    {
      var life = lives.getFirstAlive();
      life.setActive(false);
      life.setVisible(false);
    }
    function enemyMovement(enemy)
    {
        var distance = Phaser.Math.Distance.Between(enemy.x,enemy.y,player.x,player.y);

        var speed = enemySpeed;
        if(distance <= sightRange || enemy == otto){
        if(enemy == otto)
        {
          if(player.x >= enemy.x)
            {
              enemy.anims.play ('otto',true);
            }
            else
            {
              enemy.anims.play ('ottoleft',true);
            }
         speed = enemySpeed*3;
       }
       else{
          if(player.x >= enemy.x)
            {
              enemy.anims.play ('enemyright',true);
            }
            else
            {
              enemy.anims.play ('enemyleft',true);
            }
       }

          switch(Phaser.Math.RND.between(0,1)) {
            case 0:
            if(player.x < enemy.x)
            {
              enemy.setVelocityX(-speed);
              enemy.setVelocityY(0);
            }
            else if(player.x > enemy.x) {
              enemy.setVelocityX(speed);
              enemy.setVelocityY(0);
            }
                  break;
            case 1:
            if(player.y > enemy.y)
            {
            enemy.setVelocityY(speed);
            enemy.setVelocityX(0);
            }
            else if (player.y < enemy.y)
            {
              enemy.setVelocityY(-speed);
              enemy.setVelocityX(0);
            }
                              break;

              }
        }
        else{
          //set idle state for enemies
              enemy.setVelocityY(0);
              enemy.setVelocityX(0);
        }
    }
    function enemyShoot()
    {
      enemies.children.iterate(function (enemy) {
        var distanceX = Math.abs(enemy.x - player.x);
        var distanceY = Math.abs(enemy.y - player.y);
        var distance = Phaser.Math.Distance.Between(enemy.x,enemy.y,player.x,player.y);
        if(distance <= sightRange){
        if(!enemy.child.active && ((distanceX > distanceY - detectionOffset  && distanceX < distanceY + detectionOffset) || (distanceY > distanceX - detectionOffset  && distanceY < distanceX + detectionOffset)) && enemy.active){
          enemy.child.setActive(true);
          enemy.child.setVisible(true);
          enemy.child.enableBody();
          enemy.child.x = enemy.x;
          enemy.child.y = enemy.y;

          if((player.y > enemy.y) && (player.x < enemy.x))
          {
            enemy.child.setVelocityY(projectileSpeed/2);
            enemy.child.setVelocityX(-projectileSpeed/2);
          }
          else if ((player.y < enemy.y) && (player.x < enemy.x))
          {
            enemy.child.setVelocityY(-projectileSpeed/2);
            enemy.child.setVelocityX(-projectileSpeed/2);
          }
          else if((player.x > enemy.x)&& (player.y > enemy.y))
          {
            enemy.child.setVelocityY(projectileSpeed/2);
            enemy.child.setVelocityX(projectileSpeed/2);
          }
          else if((player.x > enemy.x)&&(player.y < enemy.y))
           {
             enemy.child.setVelocityY(-projectileSpeed/2);
             enemy.child.setVelocityX(projectileSpeed/2);
          }

        }
         else if(!enemy.child.active && ((enemy.x >= player.x - detectionOffset && enemy.x <= player.x + detectionOffset) || (enemy.y >= player.y - detectionOffset && enemy.y <= player.y + detectionOffset)) && enemy.active)
        {
          enemy.child.setActive(true);
          enemy.child.setVisible(true);
          enemy.child.enableBody();
          enemy.child.x = enemy.x;
          enemy.child.y = enemy.y;

          if((enemy.y >= player.y - detectionOffset && enemy.y <= player.y + detectionOffset) && (player.x < enemy.x))
          {
            enemy.child.setVelocityX(-projectileSpeed);
            enemy.child.setVelocityY(0);
          }
          else if((enemy.y >= player.y - detectionOffset && enemy.y <= player.y + detectionOffset) && (player.x > enemy.x))
          {
            enemy.child.setVelocityX(projectileSpeed);
            enemy.child.setVelocityY(0);
          }
          else if((enemy.x >= player.x - detectionOffset && enemy.x <= player.x + detectionOffset) && (player.y < enemy.y))
          {
            enemy.child.setVelocityX(0);
            enemy.child.setVelocityY(-projectileSpeed);
          }
          else if((enemy.x >= player.x - detectionOffset && enemy.x <= player.x + detectionOffset) && (player.y > enemy.y))
          {
            enemy.child.setVelocityX(0);
            enemy.child.setVelocityY(projectileSpeed);
          }
        }
        enemy.child.anims.play('bone',true);
      }});
    }
    function update (time, delta)
    {
      this.time = time;
      controls(time);
      if(player.active)
      {
        enemies.children.iterate(function (enemy) {enemyMovement(enemy)});
        enemyMovement(otto);

        if(!firstRoom)
        {
        enemyShoot();
        }
      }
      else{
        enemies.children.iterate(function (enemy) {
        enemy.setVelocityY(0);
        enemy.setVelocityX(0);
        });
        otto.setVelocityY(0);
        otto.setVelocityX(0);
      }
        //Makes the player unable to move while shooting
        if(isShooting)
        {
          player.setVelocityY(0);
          player.setVelocityX(0);
        }

        // Timer for shooting
        if(time >= shootingTimer + shootingDelay)
        {
          canShoot = true;
        }

        callOtto(time);
    }
    function controls(time)
    {
      if (cursors.left.isDown&& player.active)
      {
          player.setVelocityX(-playerSpeed);

          if(!isShooting)
          {
            player.anims.play('left', true);
          }
          facingRight = false;
      }

      if (cursors.right.isDown&& player.active)
      {
          player.setVelocityX(playerSpeed);

          if (!isShooting)
          {
            player.anims.play('right', true);
          }

          facingRight = true;
      }

      if (cursors.up.isDown&& player.active)
      {
          player.setVelocityY(-playerSpeed);

          if(facingRight && !isShooting)
          {
            player.anims.play('right', true);
          }
          else if(!facingRight && !isShooting)
            {
              player.anims.play('left', true);
            }
      }

      if (cursors.down.isDown&& player.active)
      {
          player.setVelocityY(playerSpeed);

          if(facingRight && !isShooting)
          {
            player.anims.play('right', true);
          }
          else if(!facingRight && !isShooting)
            {
              player.anims.play('left', true);
            }
      }

      if (cursors.down.isUp && cursors.up.isUp)
      {
          player.setVelocityY(0);
      }

      if(cursors.left.isUp && cursors.right.isUp)
      {
        player.setVelocityX(0);
      }

      if (cursors.down.isUp && cursors.up.isUp && cursors.left.isUp && cursors.right.isUp&& player.active)
      {
        if(facingRight)
        {
          player.anims.play('idleright', true);
        }
        else
        {
            player.anims.play('idleleft', true);
        }
      }

      if (button.isDown && (cursors.down.isDown || cursors.up.isDown || cursors.left.isDown||cursors.right.isDown) && canShoot && player.active)
      {
        fireProjectile(time,player);
      }

      if (button.isDown && !player.active && lives.countActive(true) != 0)
      {
        toggleLevelOff(currentRoom);
        toggleLevelOn(currentRoom);
        player.x = entryX;
        player.y = entryY;
        resetOtto(time);
        ottoTimer = time;
        resetEnemies(time);
        player.setActive(true);
        player.setVisible(true);
        player.enableBody();
      }

      if (button.isUp)
      {
        isShooting = false;
      }
    }
    function fireProjectile(time , parent)
    {

      var projectile = projectiles.getFirstDead();
        projectile.enableBody();
        projectile.setVisible(true);
        projectile.setActive(true);
        projectile.anims.play('player_projectile',true);
        parent.child = projectile;
        isShooting = true;
        canShoot = false;
        shootingTimer = time;

        if(facingRight){
        parent.anims.play('playerThrowRight',true);
      }
      else {
        parent.anims.play('playerThrowLeft',true);
      }

        if (cursors.down.isDown && cursors.right.isDown)
        {
          projectile.setVelocityY(projectileSpeed);
          projectile.setVelocityX(projectileSpeed);
        }
        else if (cursors.down.isDown && cursors.left.isDown)
        {
          projectile.setVelocityY(projectileSpeed);
          projectile.setVelocityX(-projectileSpeed);
        }
        else if (cursors.up.isDown && cursors.right.isDown)
        {
          projectile.setVelocityY(-projectileSpeed);
        projectile.setVelocityX(projectileSpeed);
        }
        else if (cursors.up.isDown && cursors.left.isDown)
        {
          projectile.setVelocityY(-projectileSpeed);
          projectile.setVelocityX(-projectileSpeed);
        }
        else if (cursors.left.isDown)
        {
          projectile.setVelocityX(-projectileSpeed);
            projectile.setVelocityY(0);
        }
        else if (cursors.right.isDown)
        {
          projectile.setVelocityX(projectileSpeed);
            projectile.setVelocityY(0);
        }
        else if (cursors.up.isDown)
        {
          projectile.setVelocityX(0);
          projectile.setVelocityY(-projectileSpeed);
        }
        else if (cursors.down.isDown)
        {
          projectile.setVelocityX(0);
          projectile.setVelocityY(projectileSpeed);
        }
        woosh.play();
        projectile.setX(parent.x);
        projectile.setY(parent.y);
    }
    function destroyOtherNoPoints(other, object)
    {
      if(other == otto)
      {
        object.disableBody(true,true);
        object.setActive(false);
        wallcrush.play();
      }
      else{
       if(object.child != other)
      {
          other.disableBody(true,true);
          other.setActive(false);

          if(other == player)
          {
            removeLife();
          }

      }
    }
    }
    function destroyOtherPoints(object,other)
    {
          other.disableBody(true,true);
          other.setActive(false);
          score += 50;
          scoreText.setText('Score: ' + score);
    }
    function destroyBothPoints(object1, object2)
    {
      if(object1.child != object2)
      {
      object1.disableBody(true,true);
      object1.setActive(false);
      object2.disableBody(true,true);
      object2.setActive(false);
      score += 50;
      scoreText.setText('Score: ' + score);

      if(object1 == player || object2 == player)
      {
        grunt.play();
        removeLife();
      }

      }
    }
    function destroyBothNoPoints(object1, object2)
    {
      object1.disableBody(true,true);
      object2.disableBody(true,true);
      object1.setActive(false);
      object2.setActive(false);

      if(object1 == player || object2 == player)
      {
        grunt.play();
        removeLife();
      }
    }
    function createBoarder()
    {
      boarderWalls.create((unit/2)+unit*0, (unit/2)+unit*0, 'upperleftwall'); // top left corner
      boarderWalls.create((unit/2)+unit*31, (unit/2)+unit*0, 'upperrightwall');
      boarderWalls.create((unit/2)+unit*31, (unit/2)+unit*21, 'lowerrightwall');
      boarderWalls.create((unit/2)+unit*0, (unit/2)+unit*21, 'lowerleftwall');

      //top left vert segment
      for(var i = 1; i <= 7; i++)
      {
        boarderWalls.create((unit/2)+unit*0, (unit/2)+unit*i, 'verticalwall');
      }
      boarderWalls.create((unit/2)+unit*0, (unit/2)+unit*8, 'endcapdown');
      //bottom left vert segment
      for(var i = 14; i <= 20; i++)
      {
        boarderWalls.create((unit/2)+unit*0, (unit/2)+unit*i, 'verticalwall');
      }
      boarderWalls.create((unit/2)+unit*0, (unit/2)+unit*13, 'endcapup');
      //top right vert segment
      for(var i = 1; i <= 7; i++)
      {
        boarderWalls.create((unit/2)+unit*31, (unit/2)+unit*i, 'verticalwall');
      }
      boarderWalls.create((unit/2)+unit*31, (unit/2)+unit*8, 'endcapdown');
      //bottom right vert segment
      for(var i = 14; i <= 20; i++)
      {
        boarderWalls.create((unit/2)+unit*31, (unit/2)+unit*i, 'verticalwall');
      }
      boarderWalls.create((unit/2)+unit*31, (unit/2)+unit*13, 'endcapup');

      for(var i = 1; i <= 12; i++)
      {
        boarderWalls.create((unit/2)+unit*i, (unit/2)+unit*21, 'horizontalwall');
      }
      boarderWalls.create((unit/2)+unit*13, (unit/2)+unit*21, 'endcapright');

      for(var i = 19; i <= 30; i++)
      {
        boarderWalls.create((unit/2)+unit*i, (unit/2)+unit*21, 'horizontalwall');
      }
      boarderWalls.create((unit/2)+unit*18, (unit/2)+unit*21, 'endcapleft');

      for(var i = 1; i <= 12; i++)
      {
        boarderWalls.create((unit/2)+unit*i, (unit/2)+unit*0, 'horizontalwall');
      }
      boarderWalls.create((unit/2)+unit*13, (unit/2)+unit*0, 'endcapright');

      for(var i = 19; i <= 30; i++)
      {
        boarderWalls.create((unit/2)+unit*i, (unit/2)+unit*0, 'horizontalwall');
      }
      boarderWalls.create((unit/2)+unit*18, (unit/2)+unit*0, 'endcapleft');



    }
    function createNextRoomColliders()
    {
      nextRoomColliders.create(10,350,'verticalCollider'); //leftExit 0
      nextRoomColliders.create(510,10, 'horizontalCollider');//topExit 1
      nextRoomColliders.create(1010,350,'verticalCollider');//rightExit 2
      nextRoomColliders.create(510,695,'horizontalCollider');//bottomExit 3

      doors.create(20,350,'verticalCollider'); //leftExit 0
      doors.create(510,20, 'horizontalCollider');//topExit 1
      doors.create(1000,350,'verticalCollider');//rightExit 2
      doors.create(510,685,'horizontalCollider');//bottomExit 3

      var i =0;
      nextRoomColliders.children.iterate(function (exit) {
        exit.child = i;
        i++;
      });

      i =0;
      doors.children.iterate(function (exit) {
        exit.child = i;
        exit.setActive(false);
        exit.disableBody();
        exit.setVisible(false);
        i++
      });

      nextRoomColliders.toggleVisible();
    }
    function toggleLevelOff(level)
    {
      level.children.iterate(function (levelWall) {
         levelWall.disableBody();
         levelWall.setActive(false);
         levelWall.setVisible(false);
       });
    }
    function toggleLevelOn(level)
    {
      level.children.iterate(function (levelWall) {
         levelWall.enableBody(true,true);
         levelWall.setActive(true);
         levelWall.setVisible(true);
       });
    }
    function loadNextRoom(player,collider)
    {
      if(collider.child == 0)
      {
        player.x = 940;
        closeDoor(2);
      }
      else if(collider.child == 1)
      {
        player.y = 620;
        closeDoor(3);
      }
      else if(collider.child == 2)
      {
        player.x = 50;
        closeDoor(0);
      }
      else if (collider.child == 3)
        {
          player.y = 80;
          closeDoor(1);
        }

        entryX = player.x;
        entryY = player.y;
        firstRoom = false;
        resetOtto(time);

        if(enemies.countActive() == 0)
        {
        score += 100;
        scoreText.setText('Score: ' + score);
        }

      pickRoom();
      toggleLevelOff(currentRoom);
      currentRoom = nextRoom;
      resetEnemies(time);
      toggleLevelOn(currentRoom);
    }
    function pickRoom()
    {
      switch (Phaser.Math.RND.between(0,1)) {
        case 0:
            nextRoom = levelOneWalls;
          break;
        case 1:
            nextRoom = levelTwoWalls;
            break;
      }
    }
    function callOtto(time)
    {
      var delay = Phaser.Math.RND.between(10,20)*1000;
      if(time >= ottoTimer + delay)
      {
        if(firstRoom)
        {
          otto.x = 40;
          otto.y = 300;
        }
        else
          {
            otto.x = entryX;
            otto.y = entryY;
          }
          ottoTimer = 50000000;
        otto.enableBody();
        otto.setVisible(true);
        otto.setActive(true);
        growl.play();
      }
    }
    function closeDoor(direction)
    {
      doors.children.iterate(function (exit) {
        if(exit.child == direction)
        {
          exit.setActive(true);
          exit.setVisible(true);
          exit.enableBody(true,true);
        }
        else {
          exit.setActive(false);
          exit.setVisible(false);
          exit.disableBody();
        }
      });
    }
    function resetOtto(time)
    {
      otto.disableBody();
      otto.setVisible(false);
      otto.setActive(false);
      otto.setVelocityY(0);
      otto.setVelocityX(0);
      if(firstRoom)
      {
        ottoTimer = 0;
      }
      else{
      ottoTimer = time;
      }
    }
    function createLevelOne()
    {
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*2,(unit/2)+unit*19));
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*2,(unit/2)+unit*15));
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*5,(unit/2)+unit*7));
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*8,(unit/2)+unit*3));
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*12,(unit/2)+unit*2));
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*13,(unit/2)+unit*11));
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*17,(unit/2)+unit*15));
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*24,(unit/2)+unit*19));
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*28,(unit/2)+unit*16));
      levelOnePosList.add(new Phaser.Geom.Point((unit/2)+unit*25,(unit/2)+unit*11));

      for(var i = 2; i <= 10; i++)
      {
        levelOneWalls.create((unit/2)+unit*i, (unit/2)+unit*13, 'horizontalwall');
      }
      levelOneWalls.create((unit/2)+unit*1, (unit/2)+unit*13, 'endcapleft');
      for(var i = 12; i <= 18; i++)
      {
        levelOneWalls.create((unit/2)+unit*i, (unit/2)+unit*9, 'horizontalwall');
      }
      levelOneWalls.create((unit/2)+unit*19, (unit/2)+unit*9, 'endcapright');
      for(var i = 5; i <= 13; i++)
      {
        levelOneWalls.create((unit/2)+unit*i, (unit/2)+unit*5, 'horizontalwall');
      }
      for(var i = 5; i <= 6; i++)
      {
        levelOneWalls.create((unit/2)+unit*i, (unit/2)+unit*9, 'horizontalwall');
      }
      levelOneWalls.create((unit/2)+unit*7, (unit/2)+unit*9, 'endcapright');
      for(var i = 2; i <= 5; i++)
      {
        levelOneWalls.create((unit/2)+unit*i, (unit/2)+unit*17, 'horizontalwall');
      }
      levelOneWalls.create((unit/2)+unit*10, (unit/2)+unit*17, 'endcapleft');
      levelOneWalls.create((unit/2)+unit*1, (unit/2)+unit*17, 'endcapleft');
      levelOneWalls.create((unit/2)+unit*6, (unit/2)+unit*17, 'endcapright');
      for(var i = 11; i <= 22; i++)
      {
        levelOneWalls.create((unit/2)+unit*i, (unit/2)+unit*17, 'horizontalwall');
      }

      for(var i = 19; i <= 21; i++)
      {
        levelOneWalls.create((unit/2)+unit*i, (unit/2)+unit*5, 'horizontalwall');
      }

      for(var i = 24; i <= 26; i++)
      {
        levelOneWalls.create((unit/2)+unit*i, (unit/2)+unit*9, 'horizontalwall');
      }

      for(var i = 28; i <= 29; i++)
      {
        levelOneWalls.create((unit/2)+unit*i, (unit/2)+unit*13, 'horizontalwall');
      }
      levelOneWalls.create((unit/2)+unit*30, (unit/2)+unit*13, 'endcapright');

      for(var i = 6; i <= 8; i++)
      {
        levelOneWalls.create((unit/2)+unit*4, (unit/2)+unit*i, 'verticalwall');
      }

        levelOneWalls.create((unit/2)+unit*10, (unit/2)+unit*4, 'solowall');

      for(var i = 1; i <= 4; i++)
      {
        levelOneWalls.create((unit/2)+unit*14, (unit/2)+unit*i, 'verticalwall');
      }

      for(var i = 2; i <= 4; i++)
      {
        levelOneWalls.create((unit/2)+unit*18, (unit/2)+unit*i, 'verticalwall');
      }
      levelOneWalls.create((unit/2)+unit*18, (unit/2)+unit*1, 'endcapup');

        levelOneWalls.create((unit/2)+unit*22, (unit/2)+unit*4, 'endcapup');

      for(var i = 10; i <= 12; i++)
      {
        levelOneWalls.create((unit/2)+unit*11, (unit/2)+unit*i, 'verticalwall');
      }
      for(var i = 14; i <= 15; i++)
      {
        levelOneWalls.create((unit/2)+unit*15, (unit/2)+unit*i, 'verticalwall');
      }
      levelOneWalls.create((unit/2)+unit*15, (unit/2)+unit*13, 'endcapup');
      levelOneWalls.create((unit/2)+unit*15, (unit/2)+unit*16, 'endcapdown');
      for(var i = 14; i <= 15; i++)
      {
        levelOneWalls.create((unit/2)+unit*19, (unit/2)+unit*i, 'verticalwall');
      }
      levelOneWalls.create((unit/2)+unit*19, (unit/2)+unit*13, 'endcapup');
      levelOneWalls.create((unit/2)+unit*19, (unit/2)+unit*16, 'endcapdown');
      for(var i = 10; i <= 16; i++)
      {
        levelOneWalls.create((unit/2)+unit*23, (unit/2)+unit*i, 'verticalwall');
      }
      for(var i = 10; i <= 12; i++)
      {
        levelOneWalls.create((unit/2)+unit*27, (unit/2)+unit*i, 'verticalwall');
      }

      levelOneWalls.create((unit/2)+unit*4, (unit/2)+unit*5, 'upperleftwall');
      levelOneWalls.create((unit/2)+unit*11, (unit/2)+unit*9, 'upperleftwall');
      levelOneWalls.create((unit/2)+unit*23, (unit/2)+unit*9, 'upperleftwall');
      levelOneWalls.create((unit/2)+unit*4, (unit/2)+unit*9, 'lowerleftwall');
      levelOneWalls.create((unit/2)+unit*18, (unit/2)+unit*5, 'lowerleftwall');
      levelOneWalls.create((unit/2)+unit*27, (unit/2)+unit*13, 'lowerleftwall');
      levelOneWalls.create((unit/2)+unit*14, (unit/2)+unit*5, 'lowerrightwall');
      levelOneWalls.create((unit/2)+unit*22, (unit/2)+unit*5, 'lowerrightwall');
      levelOneWalls.create((unit/2)+unit*11, (unit/2)+unit*13, 'lowerrightwall');
      levelOneWalls.create((unit/2)+unit*23, (unit/2)+unit*17, 'lowerrightwall');
      levelOneWalls.create((unit/2)+unit*27, (unit/2)+unit*9, 'upperrightwall');
      levelOneWalls.create((unit/2)+unit*14, (unit/2)+unit*0, 'endcapup');

    }
    function createLevelTwo()
    {
      levelTwoPosList.add(new Phaser.Geom.Point((unit/2)+unit*2,(unit/2)+unit*19));
      levelTwoPosList.add(new Phaser.Geom.Point((unit/2)+unit*8,(unit/2)+unit*2));
      levelTwoPosList.add(new Phaser.Geom.Point((unit/2)+unit*15,(unit/2)+unit*9));
      levelTwoPosList.add(new Phaser.Geom.Point((unit/2)+unit*11,(unit/2)+unit*14));
      levelTwoPosList.add(new Phaser.Geom.Point((unit/2)+unit*25,(unit/2)+unit*2));
      levelTwoPosList.add(new Phaser.Geom.Point((unit/2)+unit*24,(unit/2)+unit*6));
      levelTwoPosList.add(new Phaser.Geom.Point((unit/2)+unit*24,(unit/2)+unit*19));

      levelTwoWalls.create((unit/2)+unit*10, (unit/2)+unit*1, 'endcapup');
      levelTwoWalls.create((unit/2)+unit*10, (unit/2)+unit*2, 'endcapdown');
      levelTwoWalls.create((unit/2)+unit*13, (unit/2)+unit*1, 'endcapup');
      for(var i = 2; i <= 7; i++)
      {
        levelTwoWalls.create((unit/2)+unit*13, (unit/2)+unit*i, 'verticalwall');
      }
      levelTwoWalls.create((unit/2)+unit*13, (unit/2)+unit*8, 'endcapdown');
      levelTwoWalls.create((unit/2)+unit*4, (unit/2)+unit*8, 'endcapdown');
      for(var i = 5; i <= 7; i++)
      {
        levelTwoWalls.create((unit/2)+unit*4, (unit/2)+unit*i, 'verticalwall');
      }
      levelTwoWalls.create((unit/2)+unit*4, (unit/2)+unit*4, 'upperleftwall');
      for(var i = 5; i <= 6; i++)
      {
        levelTwoWalls.create((unit/2)+unit*i, (unit/2)+unit*4, 'horizontalwall');
      }
      levelTwoWalls.create((unit/2)+unit*7, (unit/2)+unit*4, 'upperrightwall');
      for(var i = 5; i <= 6; i++)
      {
        levelTwoWalls.create((unit/2)+unit*7, (unit/2)+unit*i, 'verticalwall');
      }
      levelTwoWalls.create((unit/2)+unit*7, (unit/2)+unit*7, 'lowerleftwall');
      levelTwoWalls.create((unit/2)+unit*8, (unit/2)+unit*7, 'horizontalwall');
      levelTwoWalls.create((unit/2)+unit*9, (unit/2)+unit*7, 'upperrightwall');
      levelTwoWalls.create((unit/2)+unit*9, (unit/2)+unit*8, 'endcapdown');
      levelTwoWalls.create((unit/2)+unit*1, (unit/2)+unit*13, 'endcapleft');
      for(var i = 2; i <= 3; i++)
      {
        levelTwoWalls.create((unit/2)+unit*i, (unit/2)+unit*13, 'horizontalwall');
      }
      levelTwoWalls.create((unit/2)+unit*4, (unit/2)+unit*13, 'lowerrightwall');
      levelTwoWalls.create((unit/2)+unit*4, (unit/2)+unit*12, 'upperleftwall');
      levelTwoWalls.create((unit/2)+unit*5, (unit/2)+unit*12, 'endcapright');
      levelTwoWalls.create((unit/2)+unit*4, (unit/2)+unit*17, 'endcapleft');
      levelTwoWalls.create((unit/2)+unit*5, (unit/2)+unit*17, 'endcapright');

      levelTwoWalls.create((unit/2)+unit*18, (unit/2)+unit*19, 'endcapup');
      levelTwoWalls.create((unit/2)+unit*18, (unit/2)+unit*20, 'endcapdown');
      levelTwoWalls.create((unit/2)+unit*30, (unit/2)+unit*17, 'horizontalwall');
      levelTwoWalls.create((unit/2)+unit*29, (unit/2)+unit*17, 'endcapleft');
      levelTwoWalls.create((unit/2)+unit*18, (unit/2)+unit*1, 'endcapup');
      levelTwoWalls.create((unit/2)+unit*17, (unit/2)+unit*4, 'endcapdown');
      levelTwoWalls.create((unit/2)+unit*17, (unit/2)+unit*3, 'upperleftwall');
      levelTwoWalls.create((unit/2)+unit*18, (unit/2)+unit*3, 'lowerrightwall');
      levelTwoWalls.create((unit/2)+unit*18, (unit/2)+unit*2, 'verticalwall');

      for(var i = 13; i <= 16; i++)
      {
        levelTwoWalls.create((unit/2)+unit*9, (unit/2)+unit*i, 'verticalwall');
      }
      levelTwoWalls.create((unit/2)+unit*9, (unit/2)+unit*17, 'endcapdown');
      levelTwoWalls.create((unit/2)+unit*10, (unit/2)+unit*12, 'upperleftwall');
      levelTwoWalls.create((unit/2)+unit*10, (unit/2)+unit*16, 'endcapleft');
      levelTwoWalls.create((unit/2)+unit*14, (unit/2)+unit*16, 'endcapright');
      for(var i = 11; i <= 13; i++)
      {
        levelTwoWalls.create((unit/2)+unit*i, (unit/2)+unit*16, 'horizontalwall');
      }
      for(var i = 10; i <= 15; i++)
      {
        levelTwoWalls.create((unit/2)+unit*i, (unit/2)+unit*12, 'horizontalwall');
      }
      levelTwoWalls.create((unit/2)+unit*16, (unit/2)+unit*12, 'lowerrightwall');
      levelTwoWalls.create((unit/2)+unit*17, (unit/2)+unit*11, 'upperleftwall');
      levelTwoWalls.create((unit/2)+unit*17, (unit/2)+unit*11, 'horizontalwall');
      levelTwoWalls.create((unit/2)+unit*18, (unit/2)+unit*11, 'endcapright');
      levelTwoWalls.create((unit/2)+unit*16, (unit/2)+unit*11, 'upperleftwall');
      levelTwoWalls.create((unit/2)+unit*9, (unit/2)+unit*12, 'upperleftwall');

      levelTwoWalls.create((unit/2)+unit*22, (unit/2)+unit*4, 'endcapleft');
      levelTwoWalls.create((unit/2)+unit*27, (unit/2)+unit*4, 'endcapright');
      levelTwoWalls.create((unit/2)+unit*27, (unit/2)+unit*8, 'endcapright');
      levelTwoWalls.create((unit/2)+unit*26, (unit/2)+unit*5, 'endcapup');
      levelTwoWalls.create((unit/2)+unit*26, (unit/2)+unit*8, 'lowerleftwall');

      for(var i = 23; i <= 26; i++)
      {
        levelTwoWalls.create((unit/2)+unit*i, (unit/2)+unit*4, 'horizontalwall');
      }
      for(var i = 6; i <= 7; i++)
      {
        levelTwoWalls.create((unit/2)+unit*26, (unit/2)+unit*i, 'verticalwall');
      }

      levelTwoWalls.create((unit/2)+unit*18, (unit/2)+unit*15, 'endcapleft');
      levelTwoWalls.create((unit/2)+unit*25, (unit/2)+unit*17, 'endcapright');
      levelTwoWalls.create((unit/2)+unit*22, (unit/2)+unit*15, 'upperrightwall');
      levelTwoWalls.create((unit/2)+unit*22, (unit/2)+unit*17, 'lowerleftwall');
      levelTwoWalls.create((unit/2)+unit*22, (unit/2)+unit*16, 'verticalwall');

      for(var i = 19; i <= 21; i++)
      {
        levelTwoWalls.create((unit/2)+unit*i, (unit/2)+unit*15, 'horizontalwall');
      }
      for(var i = 23; i <= 24; i++)
      {
        levelTwoWalls.create((unit/2)+unit*i, (unit/2)+unit*17, 'horizontalwall');
      }
      levelTwoWalls.create((unit/2)+unit*21, (unit/2)+unit*8, 'endcapleft');
      levelTwoWalls.create((unit/2)+unit*22, (unit/2)+unit*8, 'upperrightwall');
      levelTwoWalls.create((unit/2)+unit*22, (unit/2)+unit*11, 'lowerleftwall');
      levelTwoWalls.create((unit/2)+unit*24, (unit/2)+unit*11, 'upperrightwall');
      levelTwoWalls.create((unit/2)+unit*24, (unit/2)+unit*12, 'lowerleftwall');
      levelTwoWalls.create((unit/2)+unit*26, (unit/2)+unit*12, 'upperrightwall');
      levelTwoWalls.create((unit/2)+unit*26, (unit/2)+unit*13, 'endcapdown');
      levelTwoWalls.create((unit/2)+unit*23, (unit/2)+unit*11, 'horizontalwall');
      levelTwoWalls.create((unit/2)+unit*25, (unit/2)+unit*12, 'horizontalwall');
      for(var i = 9; i <= 10; i++)
      {
        levelTwoWalls.create((unit/2)+unit*22, (unit/2)+unit*i, 'verticalwall');
      }

    }
    function createAnimations(anims)
    {
      anims.create({
         key: 'left',
         frames: anims.generateFrameNumbers('dudeleft', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'right',
         frames: anims.generateFrameNumbers('duderight', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'enemyleft',
         frames: anims.generateFrameNumbers('enemyleft', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'enemyright',
         frames: anims.generateFrameNumbers('enemyright', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'otto',
         frames: anims.generateFrameNumbers('otto', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'ottoleft',
         frames: anims.generateFrameNumbers('ottoleft', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'player_projectile',
         frames: anims.generateFrameNumbers('player_projectile', { start: 0, end: 4 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'bone',
         frames: anims.generateFrameNumbers('bone', { start: 0, end: 4 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'idleright',
         frames: [ { key: 'idleright', frame: 0 } ],
         frameRate: 20
     });

     anims.create({
         key: 'idleleft',
         frames: [ { key: 'idleleft', frame: 0 } ],
         frameRate: 20
     });

     anims.create({
         key: 'playerThrowLeft',
         frames: anims.generateFrameNumbers('playerThrowLeft', { start: 0, end: 4 }),
         frameRate: 20
     });

     anims.create({
         key: 'playerThrowRight',
         frames: anims.generateFrameNumbers('playerThrowRight', { start: 0, end: 4 }),
         frameRate: 20
     });
    }
    function resetEnemies(time)
    {

        enemies.children.iterate(function (enemy) {
        enemy.disableBody();
        enemy.setVisible(false);
        enemy.setActive(false);

      });
      var posList;

      if(currentRoom == levelOneWalls)
      {
        posList = levelOnePosList;
      }
      else if(currentRoom == levelTwoWalls)
      {
        posList = levelTwoPosList;
      }

      var j = 0;
      while(j < posList.length)
      {
        var enemy = enemies.getFirstDead();
        enemy.x = posList.getAt(j).x;
        enemy.y = posList.getAt(j).y;
        enemy.enableBody();
        enemy.setVisible(true);
        enemy.setActive(true);
        j++
      }
    }
</script>

</body>
</html>
