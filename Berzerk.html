<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 7</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

    var config = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,update: update,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 0},
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var player;
    var playerPrevX;
    var playerPrevY;
    var enemies;
    var enemySpeed;
    var boarderWalls;
    var cursors;
    var button;
    var projectiles;
    var enemyProjectiles;
    var scoreText;
    var score;
    var projectileSpeed;
    var playerSpeed;
    var isShooting;
    var shootingTimer;
    var shootingDelay;
    var canShoot;
    var facingRight;
    var levelOneWalls;
    var levelTwoWalls;
    var nextRoomColliders;
    var detectionOffset;
    var currentRoom;
    var nextRoom;
    var enemyCantShoot;
    var lives;
    var otto;
    var ottoTimer;
    var time;
    var entryX;
    var entryY;
    var doors;
    var canTakeDamage;
    var respawnTimer;
    var unit;

    var game = new Phaser.Game(config);

    function preload ()
    {
        this.load.image('BG', 'assets/floorsprites.png');
        this.load.image('horizontalwall', 'assets/horizontalwall.png');
      this.load.image('verticalwall', 'assets/verticalwall.png');
      this.load.image('horizontalCollider', 'assets/horizontalCollider.png');
      this.load.image('verticalCollider', 'assets/verticalCollider.png');
      this.load.spritesheet('bone', 'assets/skeleton_projectile_sheet_small.png', { frameWidth: 14, frameHeight: 14 });
      this.load.spritesheet('player_projectile', 'assets/player_projectile.png', { frameWidth: 14, frameHeight: 14 });
      this.load.spritesheet('otto', 'assets/minotaur_walk_sheet.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('ottoleft', 'assets/minotaur_walk_sheetleft.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('duderight', 'assets/player_walkcycle_sheet.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('dudeleft', 'assets/player_walkcycle_sheetleft.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('idleright', 'assets/player_sprite.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('idleleft', 'assets/player_spriteleft.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('enemyright', 'assets/skeleton_walk_sheet.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('enemyleft', 'assets/skeleton_walk_sheetleft.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('playerThrowRight', 'assets/player_throw_sheet_right.png', { frameWidth: 32, frameHeight: 32 });
      this.load.spritesheet('playerThrowLeft', 'assets/player_throw_sheet_left.png', { frameWidth: 32, frameHeight: 32 });

        projectileSpeed = 250;
        playerSpeed = 120;
        enemySpeed = 100;
        isShooting = false;
        canShoot = true;
        shootingTimer = 0;
        shootingDelay = 1000; // 1000 = 1 second
        facingRight = true;
        score = 0;
        playerPrevX = 0;
        playerPrevY = 0;
        detectionOffset = 15;
        enemyCantShoot = true;
        respawnTimer = 5000000;
        respawnDelay = 2000;
        firstRoom = true;
        unit = 32;
    }

    function create ()
    {
        this.add.image(400, 300, 'BG');
        nextRoomColliders = this.physics.add.staticGroup();
        doors = this.physics.add.staticGroup();
        boarderWalls = this.physics.add.staticGroup();
        levelOneWalls = this.physics.add.staticGroup();
        levelTwoWalls = this.physics.add.staticGroup();
        lives = this.add.group();
        otto = this.physics.add.sprite(500, 450, 'otto');

        resetOtto();

        enemies = this.physics.add.group();
        enemies.createMultiple({
    key: 'enemyright',visible:true,active:true,
    repeat: 4,
    setXY: { x: 200, y: 100,stepX: 70, stepY: 50}
        });
        createNextRoomColliders();
        createBoarder(); // creats the wall for the game boarder.
        createLevelOne();
        createLevelTwo();
        toggleLevelOff(levelTwoWalls);
        currentRoom = levelOneWalls;
        nextRoom = levelTwoWalls;


        projectiles = this.physics.add.group();
        projectiles.createMultiple({
    key: 'player_projectile',visible:false,active:false,
    repeat: 2,
    setXY: { x: 0, y: 580}
          });

          lives.createMultiple({
      key: 'duderight',visible:true,active:true,
      repeat: 2,
      setXY: { x: 200, y: 565 , stepX: 40}
            });

          var i = 0;
          enemyProjectiles = this.physics.add.group();
          enemyProjectiles.createMultiple({
      key: 'bone',visible:false,active:false,
      repeat: 15,
      setXY: { x: 0, y: 580}
            });
              enemies.children.iterate(function (enemy) {
                enemy.child = enemyProjectiles.getFirstNth(i);
                enemy.child.disableBody();
                i++;
              });
        player = this.physics.add.sprite(100, 450, 'duderight');
        player.setCollideWorldBounds(true);
        createAnimations(this.anims);// creates the animations. passes in the animator from the game

        cursors = this.input.keyboard.createCursorKeys();
        button = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        this.physics.add.overlap(nextRoomColliders, player, loadNextRoom, null, this);
        this.physics.add.overlap(enemies, projectiles, destroyBothPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, projectiles, destroyBothNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, player, destroyBothNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles,enemies , destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemies, player, destroyBothPoints, null, this);
        this.physics.add.overlap(projectiles, boarderWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(projectiles, levelOneWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, levelOneWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, boarderWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, nextRoomColliders, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(player, otto, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemies, otto, destroyOtherPoints, null, this);
        this.physics.add.overlap(projectiles, levelTwoWalls, destroyOtherNoPoints, null, this);
        this.physics.add.overlap(enemyProjectiles, levelTwoWalls, destroyOtherNoPoints, null, this);
        this.physics.add.collider(player, boarderWalls);
        this.physics.add.collider(player, levelOneWalls);
        this.physics.add.collider(player, doors);
        this.physics.add.collider(otto, boarderWalls);
        this.physics.add.collider(otto, levelOneWalls);
        this.physics.add.collider(otto, levelTwoWalls);
        this.physics.add.collider(enemies, boarderWalls);
        this.physics.add.collider(enemies, enemies);
        this.physics.add.collider(enemies, levelOneWalls);
        this.physics.add.collider(enemies, levelTwoWalls);

        entryX = player.x;
        entryY = player.y;

        scoreText = this.add.text(400, 550, 'score: 0', { fontSize: '32px', fill: '#000' });
    }

    function removeLife()
    {
      var life = lives.getFirstAlive();
      life.setActive(false);
      life.setVisible(false);
    }
    function enemyMovement(enemy)
    {
        var distanceX = Math.abs(enemy.x - player.x);
        var distanceY = Math.abs(enemy.y - player.y);

        var speed = enemySpeed;

        if(enemy == otto)
        {
          enemy.anims.play ('otto',true);
         speed = enemySpeed+50;
       }
       else{
         enemy.anims.play ('enemyright',true);
       }

        if((distanceX > distanceY - detectionOffset  && distanceX < distanceY + detectionOffset) || (distanceY > distanceX - detectionOffset  && distanceY < distanceX + detectionOffset))
          {
            if((player.y > enemy.y) && (player.x < enemy.x))
            {
            enemy.setVelocityY(speed);
            enemy.setVelocityX(-speed);
            }
            else if ((player.y < enemy.y) && (player.x < enemy.x))
            {
              enemy.setVelocityY(-speed);
              enemy.setVelocityX(-speed);
            }
            else if((player.x > enemy.x)&& (player.y > enemy.y))
            {
              enemy.setVelocityY(speed);
              enemy.setVelocityX(speed);
            }
            else if((player.x > enemy.x)&&(player.y < enemy.y))
             {
              enemy.setVelocityX(speed);
              enemy.setVelocityY(-speed);
            }
        }
        else{
          if((distanceX <= distanceY && distanceX != 0) || (distanceY ==0))
          {
            if(player.x < enemy.x)
            {
              enemy.setVelocityX(-speed);
              enemy.setVelocityY(0);
            }
            else if(player.x > enemy.x) {
              enemy.setVelocityX(speed);
              enemy.setVelocityY(0);
            }
          }
          else if((distanceY <= distanceX  && distanceY != 0) || (distanceX ==0))
          {
            if(player.y > enemy.y)
            {
            enemy.setVelocityY(speed);
            enemy.setVelocityX(0);
            }
            else if (player.y < enemy.y)
            {
              enemy.setVelocityY(-speed);
              enemy.setVelocityX(0);
            }
          }
        }
    }
    function enemyShoot()
    {
      enemies.children.iterate(function (enemy) {
        var distanceX = Math.abs(enemy.x - player.x);
        var distanceY = Math.abs(enemy.y - player.y);

        if(!enemy.child.active && ((distanceX > distanceY - detectionOffset  && distanceX < distanceY + detectionOffset) || (distanceY > distanceX - detectionOffset  && distanceY < distanceX + detectionOffset)) && enemy.active){
          enemy.child.setActive(true);
          enemy.child.setVisible(true);
          enemy.child.enableBody();
          enemy.child.x = enemy.x;
          enemy.child.y = enemy.y;

          if((player.y > enemy.y) && (player.x < enemy.x))
          {
            enemy.child.setVelocityY(projectileSpeed/2);
            enemy.child.setVelocityX(-projectileSpeed/2);
          }
          else if ((player.y < enemy.y) && (player.x < enemy.x))
          {
            enemy.child.setVelocityY(-projectileSpeed/2);
            enemy.child.setVelocityX(-projectileSpeed/2);
          }
          else if((player.x > enemy.x)&& (player.y > enemy.y))
          {
            enemy.child.setVelocityY(projectileSpeed/2);
            enemy.child.setVelocityX(projectileSpeed/2);
          }
          else if((player.x > enemy.x)&&(player.y < enemy.y))
           {
             enemy.child.setVelocityY(-projectileSpeed/2);
             enemy.child.setVelocityX(projectileSpeed/2);
          }

        }
         else if(!enemy.child.active && ((enemy.x >= player.x - detectionOffset && enemy.x <= player.x + detectionOffset) || (enemy.y >= player.y - detectionOffset && enemy.y <= player.y + detectionOffset)) && enemy.active)
        {
          enemy.child.setActive(true);
          enemy.child.setVisible(true);
          enemy.child.enableBody();
          enemy.child.x = enemy.x;
          enemy.child.y = enemy.y;

          if((enemy.y >= player.y - detectionOffset && enemy.y <= player.y + detectionOffset) && (player.x < enemy.x))
          {
            enemy.child.setVelocityX(-projectileSpeed);
            enemy.child.setVelocityY(0);
          }
          else if((enemy.y >= player.y - detectionOffset && enemy.y <= player.y + detectionOffset) && (player.x > enemy.x))
          {
            enemy.child.setVelocityX(projectileSpeed);
            enemy.child.setVelocityY(0);
          }
          else if((enemy.x >= player.x - detectionOffset && enemy.x <= player.x + detectionOffset) && (player.y < enemy.y))
          {
            enemy.child.setVelocityX(0);
            enemy.child.setVelocityY(-projectileSpeed);
          }
          else if((enemy.x >= player.x - detectionOffset && enemy.x <= player.x + detectionOffset) && (player.y > enemy.y))
          {
            enemy.child.setVelocityX(0);
            enemy.child.setVelocityY(projectileSpeed);
          }
        }
        enemy.child.anims.play('bone',true);
      });
    }
    function update (time, delta)
    {
      controls(time);
      if(player.active)
      {
        enemies.children.iterate(function (enemy) {enemyMovement(enemy)});
        enemyMovement(otto);

        if(!enemyCantShoot)
        {
        enemyShoot();
         }
      }
        //Makes the player unable to move while shooting
        if(isShooting)
        {
          player.setVelocityY(0);
          player.setVelocityX(0);
        }

        // Timer for shooting
        if(time >= shootingTimer + shootingDelay)
        {
          canShoot = true;
        }

        if(time >= respawnTimer + respawnDelay)
        {
          enemyCantShoot = false;
        }
        else {
          enemyCantShoot = true;
        }
        callOtto(time);
    }
    function controls(time)
    {
      this.time = time;
      if (cursors.left.isDown&& player.active)
      {
          player.setVelocityX(-playerSpeed);

          if(!isShooting)
          {
            player.anims.play('left', true);
          }
          facingRight = false;
      }

      if (cursors.right.isDown&& player.active)
      {
          player.setVelocityX(playerSpeed);

          if (!isShooting)
          {
            player.anims.play('right', true);
          }

          facingRight = true;
      }

      if (cursors.up.isDown&& player.active)
      {
          player.setVelocityY(-playerSpeed);

          if(facingRight && !isShooting)
          {
            player.anims.play('right', true);
          }
          else if(!facingRight && !isShooting)
            {
              player.anims.play('left', true);
            }
      }

      if (cursors.down.isDown&& player.active)
      {
          player.setVelocityY(playerSpeed);

          if(facingRight && !isShooting)
          {
            player.anims.play('right', true);
          }
          else if(!facingRight && !isShooting)
            {
              player.anims.play('left', true);
            }
      }

      if (cursors.down.isUp && cursors.up.isUp)
      {
          player.setVelocityY(0);
      }

      if(cursors.left.isUp && cursors.right.isUp)
      {
        player.setVelocityX(0);
      }

      if (cursors.down.isUp && cursors.up.isUp && cursors.left.isUp && cursors.right.isUp&& player.active)
      {
        if(facingRight)
        {
          player.anims.play('idleright', true);
        }
        else
        {
            player.anims.play('idleleft', true);
        }
      }

      if (button.isDown && (cursors.down.isDown || cursors.up.isDown || cursors.left.isDown||cursors.right.isDown) && canShoot && player.active)
      {
        fireProjectile(time,player);
      }

      if (button.isDown && !player.active && lives.countActive(true) != 0)
      {
        player.x = entryX;
        player.y = entryY;
        resetOtto();
        respawnTimer = time;
        resetEnemies();
        player.setActive(true);
        player.setVisible(true);
        player.enableBody();
      }

      if (button.isUp)
      {
        isShooting = false;
      }
    }
    function fireProjectile(time , parent)
    {

      var projectile = projectiles.getFirstDead();
        projectile.enableBody();
        projectile.setVisible(true);
        projectile.setActive(true);
        projectile.anims.play('player_projectile',true);
        parent.child = projectile;
        isShooting = true;
        canShoot = false;
        shootingTimer = time;

        if(facingRight){
        parent.anims.play('playerThrowRight',true);
      }
      else {
        parent.anims.play('playerThrowLeft',true);
      }

        if (cursors.down.isDown && cursors.right.isDown)
        {
          projectile.setVelocityY(projectileSpeed);
          projectile.setVelocityX(projectileSpeed);
        }
        else if (cursors.down.isDown && cursors.left.isDown)
        {
          projectile.setVelocityY(projectileSpeed);
          projectile.setVelocityX(-projectileSpeed);
        }
        else if (cursors.up.isDown && cursors.right.isDown)
        {
          projectile.setVelocityY(-projectileSpeed);
        projectile.setVelocityX(projectileSpeed);
        }
        else if (cursors.up.isDown && cursors.left.isDown)
        {
          projectile.setVelocityY(-projectileSpeed);
          projectile.setVelocityX(-projectileSpeed);
        }
        else if (cursors.left.isDown)
        {
          projectile.setVelocityX(-projectileSpeed);
            projectile.setVelocityY(0);
        }
        else if (cursors.right.isDown)
        {
          projectile.setVelocityX(projectileSpeed);
            projectile.setVelocityY(0);
        }
        else if (cursors.up.isDown)
        {
          projectile.setVelocityX(0);
          projectile.setVelocityY(-projectileSpeed);
        }
        else if (cursors.down.isDown)
        {
          projectile.setVelocityX(0);
          projectile.setVelocityY(projectileSpeed);
        }

        projectile.setX(parent.x);
        projectile.setY(parent.y);
    }
    function destroyOtherNoPoints(other, object)
    {
       if(object.child != other)
      {
          other.disableBody(true,true);
          other.setActive(false);

          if(other == player)
          {
            removeLife();
          }

      }
    }
    function destroyOtherPoints(object,other)
    {
          other.disableBody(true,true);
          other.setActive(false);
          score += 50;
          scoreText.setText('Score: ' + score);
    }
    function destroyBothPoints(object1, object2)
    {
      if(object1.child != object2)
      {
      object1.disableBody(true,true);
      object1.setActive(false);
      object2.disableBody(true,true);
      object2.setActive(false);
      score += 50;
      scoreText.setText('Score: ' + score);

      if(object1 == player || object2 == player)
      {
        removeLife();
      }

      }
    }
    function destroyBothNoPoints(object1, object2)
    {
      object1.disableBody(true,true);
      object2.disableBody(true,true);
      object1.setActive(false);
      object2.setActive(false);

      if(object1 == player || object2 == player)
      {
        removeLife();
      }
    }
    function createBoarder()
    {
      boarderWalls.create(15, 110, 'verticalwall'); // top left corner
      boarderWalls.create(110, 15, 'horizontalwall');//topleft corner
      boarderWalls.create(230, 15, 'horizontalwall');//topleft corner
        boarderWalls.create(680, 15, 'horizontalwall');//top right corner
        boarderWalls.create(775, 110, 'verticalwall');// top right corner
        boarderWalls.create(560, 15, 'horizontalwall');//topright corner
      boarderWalls.create(680, 525, 'horizontalwall');//bottom right corner
        boarderWalls.create(560, 525, 'horizontalwall');//bottom right corner
        boarderWalls.create(775, 425, 'verticalwall');// bottom right corner
        boarderWalls.create(110, 525, 'horizontalwall');//bottom left corner
      boarderWalls.create(230, 525, 'horizontalwall');//bottomleft corner
        boarderWalls.create(15, 425, 'verticalwall');// bottom left corner
    }
    function createNextRoomColliders()
    {
      nextRoomColliders.create(10,265,'verticalCollider'); //leftExit 0
      nextRoomColliders.create(395,10, 'horizontalCollider');//topExit 1
      nextRoomColliders.create(780,265,'verticalCollider');//rightExit 2
      nextRoomColliders.create(395,530,'horizontalCollider');//bottomExit 3

      doors.create(20,265,'verticalCollider'); //leftExit 0
      doors.create(395,20, 'horizontalCollider');//topExit 1
      doors.create(770,265,'verticalCollider');//rightExit 2
      doors.create(395,520,'horizontalCollider');//bottomExit 3

      var i =0;
      nextRoomColliders.children.iterate(function (exit) {
        exit.child = i;
        i++;
      });

      i =0;
      doors.children.iterate(function (exit) {
        exit.child = i;
        exit.setActive(false);
        exit.disableBody();
        exit.setVisible(false);
        i++
      });

      nextRoomColliders.toggleVisible();
    }
    function toggleLevelOff(level)
    {
      level.children.iterate(function (levelWall) {
         levelWall.disableBody();
         levelWall.setActive(false);
         levelWall.setVisible(false);
       });
    }
    function toggleLevelOn(level)
    {
      level.children.iterate(function (levelWall) {
         levelWall.enableBody(true,true);
         levelWall.setActive(true);
         levelWall.setVisible(true);
       });
    }
    function loadNextRoom(player,collider)
    {
      if(collider.child == 0)
      {
        player.x = 740;
        closeDoor(2);
      }
      else if(collider.child == 1)
      {
        player.y = 480;
        closeDoor(3);
      }
      else if(collider.child == 2)
      {
        player.x = 50;
        closeDoor(0);
      }
      else if (collider.child == 3)
        {
          player.y = 80;
          closeDoor(1);
        }

        entryX = player.x;
        entryY = player.y;
        enemyCantShoot = false;
        firstRoom = false;
        resetOtto();

        if(enemies.countActive() == 0)
        {
        score += 100;
        scoreText.setText('Score: ' + score);
        }

        resetEnemies();
      toggleLevelOn(nextRoom);
      toggleLevelOff(currentRoom);
    }
    function callOtto(time)
    {
      var delay = Phaser.Math.RND.between(7000,20000);
      if(time >= ottoTimer + delay)
      {
        if(enemyCantShoot)
        {
          otto.x = 40;
          otto.y = 300;
        }
        else
          {
            otto.x = entryX;
            otto.y = entryY;
          }
          ottoTimer = 50000000;
        otto.enableBody();
        otto.setVisible(true);
        otto.setActive(true);
      }
    }
    function closeDoor(direction)
    {
      doors.children.iterate(function (exit) {
        if(exit.child == direction)
        {
          exit.setActive(true);
          exit.setVisible(true);
          exit.enableBody(true,true);
        }
        else {
          exit.setActive(false);
          exit.setVisible(false);
          exit.disableBody();
        }
      });
    }
    function resetOtto()
    {
      otto.disableBody();
      otto.setVisible(false);
      otto.setActive(false);
      otto.setVelocityY(0);
      otto.setVelocityX(0);
      if(firstRoom)
      {
        ottoTimer = 0;
      }
      else{
      ottoTimer = this.time;
      }
    }
    function createLevelOne()
    {
      levelOneWalls.create(110, 200, 'horizontalwall');
      levelOneWalls.create(250, 400, 'horizontalwall');
      levelOneWalls.create(600, 300, 'verticalwall');
      levelOneWalls.create(510, 210, 'horizontalwall');
    }
    function createLevelTwo()
    {
      levelTwoWalls.create(500, 225, 'horizontalwall');
      levelTwoWalls.create(250, 225, 'horizontalwall');
      levelTwoWalls.create(150, 300, 'verticalwall');
      levelTwoWalls.create(400, 225, 'horizontalwall');
    }
    function createAnimations(anims)
    {
      anims.create({
         key: 'left',
         frames: anims.generateFrameNumbers('dudeleft', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'right',
         frames: anims.generateFrameNumbers('duderight', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'enemyleft',
         frames: anims.generateFrameNumbers('enemyleft', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'enemyright',
         frames: anims.generateFrameNumbers('enemyright', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'otto',
         frames: anims.generateFrameNumbers('otto', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'ottoleft',
         frames: anims.generateFrameNumbers('ottoleft', { start: 0, end: 11 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'player_projectile',
         frames: anims.generateFrameNumbers('player_projectile', { start: 0, end: 4 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'bone',
         frames: anims.generateFrameNumbers('bone', { start: 0, end: 4 }),
         frameRate: 10,
         repeat: -1
     });

     anims.create({
         key: 'idleright',
         frames: [ { key: 'idleright', frame: 0 } ],
         frameRate: 20
     });

     anims.create({
         key: 'idleleft',
         frames: [ { key: 'idleleft', frame: 0 } ],
         frameRate: 20
     });

     anims.create({
         key: 'playerThrowLeft',
         frames: anims.generateFrameNumbers('playerThrowLeft', { start: 0, end: 4 }),
         frameRate: 20
     });

     anims.create({
         key: 'playerThrowRight',
         frames: anims.generateFrameNumbers('playerThrowRight', { start: 0, end: 4 }),
         frameRate: 20
     });
    }
    function resetEnemies()
    {
      enemies.children.iterate(function (enemy) {
        enemy.disableBody();
        enemy.setVisible(false);
        enemy.setActive(false);

        enemy.x = Phaser.Math.RND.between(100,500);
        enemy.y = Phaser.Math.RND.between(100,400);
        enemy.setVelocityY(0);
        enemy.setVelocityX(0);
        enemy.enableBody();
        enemy.setVisible(true);
        enemy.setActive(true);
        respawnTimer = this.time;
      });
    }
</script>

</body>
</html>
